import * as express from 'express';
import Controller from 'routes/interfaces/controller.interface';
import validationMiddleware from '../middleware/validation.middleware';
import permissionMiddleware from '../middleware/permission.middleware';
import { CreateVulnerabilityDto, UpdateVulnerabilityDto, FindVulnerabilityDto } from './vulnerability.dto';
import VulnerabilityService from './vulnerability.service';
import HttpException from '../exceptions/HTTPException';
import Vulnerability from './vulnerability.entity';
import Evidence from '../evidences/evidence.entity';
import * as jwt from 'jsonwebtoken';
import { modifyEntries, addCompanyFilter } from '../../utils/modifyEntries';
import DataStoredInToken from '../interfaces/dataStoredInToken.interface';
import authMiddleware from '../middleware/auth.middleware';
import { VulnerabilityStatus } from '../../utils/constants';
import * as moment from 'moment';

class VulnerabilityController implements Controller {
    public path = "/vulnerabilities";
    public router = express.Router();
    private vulnerabilityService = new VulnerabilityService();

    constructor() {
        this.initializeRoutes();
    }

    private initializeRoutes() {
        this.router.post(this.path+"/search", authMiddleware, permissionMiddleware(["GET VULNERABILITIES"]), validationMiddleware(FindVulnerabilityDto), this.getVulnerabilities);
        this.router.post(this.path, authMiddleware, permissionMiddleware(["ADD VULNERABILITIES"]), validationMiddleware(CreateVulnerabilityDto), this.addVulnerability);
        this.router.all(this.path + "/*", authMiddleware);
        this.router.get(this.path + "/:id", permissionMiddleware(["GET VULNERABILITIES"]), this.getVulnerability);
        this.router.get(this.path + "/:id/evidences", permissionMiddleware(["GET VULNERABILITIES"]), this.getVulnerabilityEvidences);
        this.router.patch(this.path + "/:id", permissionMiddleware(["MODIFY VULNERABILITIES"]), validationMiddleware(UpdateVulnerabilityDto), this.modifyVulnerability);
        this.router.delete(this.path + "/:id", permissionMiddleware(["DELETE VULNERABILITIES"]), this.deleteVulnerability);
    }


    private findVulnerability = async (request: express.Request, relations) => {
        var filterCompanies = [];
        this.setFilters(request, filterCompanies)
        const vulnerability: Vulnerability = await this.vulnerabilityService.getVulnerability(filterCompanies, relations);
        return vulnerability;
    }
    private setFilters = (request: express.Request, filterCompanies) => {
        filterCompanies.push({ id: parseInt(request.params.id) });
        const secret = process.env.JWT_SECRET;
        const companies = (jwt.verify(request.header('xtoken'), secret) as DataStoredInToken).companies;
        addCompanyFilter(filterCompanies, companies);
    }
    private getVulnerabilities = async (request: express.Request, response: express.Response, next: express.NextFunction) => {
        try {
            const secret = process.env.JWT_SECRET;
            const filters: FindVulnerabilityDto[] = request.body.length > 0 ? request.body : []
            modifyEntries(filters)
            const companies = (jwt.verify(request.header('xtoken'), secret) as DataStoredInToken).companies;
            addCompanyFilter(filters, companies)
            const vulnerabilities = await this.vulnerabilityService.getVulnerabilities(filters, request.query.limit, request.query.offset);
            response.send(vulnerabilities);
        } catch (error) {
            next(new HttpException(400, error.message));
        }
    }
    private addVulnerability = async (request: express.Request, response: express.Response, next: express.NextFunction) => {
        try {
            const secret = process.env.JWT_SECRET;
            const companies = (jwt.verify(request.header('xtoken'), secret) as DataStoredInToken).companies;
            var vulnerabilityData: CreateVulnerabilityDto = request.body;
            if (companies.indexOf(vulnerabilityData.company.id) == -1) {
                next(new HttpException(400, "User does not belong to that company"))
            } else {
                const newVulnerability = await this.vulnerabilityService.addVulnerability(vulnerabilityData);
                response.status(201).send(newVulnerability);
            }
        } catch (error) {
            next(new HttpException(400, error.message))
        }
    }
    private modifyVulnerability = async (request: express.Request, response: express.Response, next: express.NextFunction) => {
        var vulnerabilityData: UpdateVulnerabilityDto = request.body;
        try {
            const vulnerability: Vulnerability = await this.findVulnerability(request, [])
            if (vulnerability) {
                const secret = process.env.JWT_SECRET;
                const permissions = (jwt.verify(request.header("xtoken"), secret) as DataStoredInToken).functionalities;
                switch (vulnerability.status) {
                    case VulnerabilityStatus.ASSUMED:
                        if (!permissions.includes("OPEN VULNERABILITIES")) {
                            next(new HttpException(401, "Not enought permissions to open a vulnerability again"));
                            return;
                        }
                        if (vulnerabilityData.status != VulnerabilityStatus.OPEN) {
                            next(new HttpException(400, "Assumed vulnerabilities can only be opened again"))
                            return;
                        }
                        break;
                    case VulnerabilityStatus.CLOSED:
                        next(new HttpException(400, "Vulnerability is closed and its status cannot change"))
                        return;
                    case VulnerabilityStatus.FALSEPOSITIVE:
                        next(new HttpException(400, "Vulnerability is closed and its status cannot change"))
                        return;
                    case VulnerabilityStatus.REVISION:
                        if (!permissions.includes("REVISION VULNERABILITIES")) {
                            next(new HttpException(401, "Not enought permissions to open a vulnerability again"));
                            return;
                        }
                        if ([VulnerabilityStatus.FALSEPOSITIVE, VulnerabilityStatus.ASSUMED, VulnerabilityStatus.ASSUMED, VulnerabilityStatus.REVISION].indexOf(vulnerabilityData.status) != -1) {
                            next(new HttpException(400, "Vulnerabilities on revision can only be closed or opened again"));
                            return;
                        } else {
                            if (VulnerabilityStatus.CLOSED == vulnerabilityData.status) {
                                vulnerabilityData.resolution_date = moment().format("YYYY-MM-DD");
                            }
                        }
                        break;
                    case VulnerabilityStatus.OPEN:
                        switch (vulnerabilityData.status) {
                            case VulnerabilityStatus.ASSUMED:
                                if (!permissions.includes("ASSUME VULNERABILITIES")) {
                                    next(new HttpException(401, "Not enought permissions to assume vulnerabilities"));
                                    return;
                                }
                            case VulnerabilityStatus.FALSEPOSITIVE:
                                if (!permissions.includes("FALSEPOSITIVE VULNERABILITIES")) {
                                    next(new HttpException(401, "Not enought permissions to set a vulnerability as a false positive"));
                                    return;
                                }
                            case VulnerabilityStatus.REVISION:
                                if (!permissions.includes("REVISION VULNERABILITIES")) {
                                    next(new HttpException(401, "Not enought permissions to send a vulnerability for revision"));
                                    return;
                                }
                            case VulnerabilityStatus.CLOSED:
                                if (!permissions.includes("CLOSE VULNERABILITIES")) {
                                    next(new HttpException(401, "Not enought permissions to close vulnerabilities"));
                                    return
                                }
                        }
                }
                const modifyedVulnerability: Vulnerability = await this.vulnerabilityService.modifyVulnerability(vulnerability, vulnerabilityData);
                response.send(modifyedVulnerability);

            } else {
                next(new HttpException(404, "Vulnerability does not exist"))
            }
        } catch (error) {
            next(new HttpException(400, error.message))
        }
    }
    private getVulnerability = async (request: express.Request, response: express.Response, next: express.NextFunction) => {
        if (!isNaN(parseInt(request.params.id))) {
            const vulnerability: Vulnerability = await this.findVulnerability(request, ["audit", "audit.asset", "audit.url"]);
            if (vulnerability)
                response.send(vulnerability);
            else next(new HttpException(404, "Vulnerability does not exist"))
        } else {
            next(new HttpException(400, "Id has to be a number"))
        }
    }
    private getVulnerabilityEvidences = async (request: express.Request, response: express.Response, next: express.NextFunction) => {
        if (!isNaN(parseInt(request.params.id))) {
            const vulnerability: Vulnerability = await this.findVulnerability(request, ["evidences"]);
            if (vulnerability)
                response.send(vulnerability.evidences);
            else next(new HttpException(404, "Vulnerability does not exist"))
        } else {
            next(new HttpException(400, "Id has to be a number"))
        }
    }
    private deleteVulnerability = async (request: express.Request, response: express.Response, next: express.NextFunction) => {
        if (!isNaN(parseInt(request.params.id))) {
            const vulnerability: Vulnerability = await this.findVulnerability(request, []);
            if (vulnerability) {
                const result = await this.vulnerabilityService.deleteVulnerability(request.params.id);
                response.sendStatus(200);
            }
            else next(new HttpException(404, "Vulnerability does not exist"))
        } else {
            next(new HttpException(400, "Id has to be a number"))
        }
    }


}

export default VulnerabilityController;
